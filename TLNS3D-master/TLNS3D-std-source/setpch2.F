c------------------------------------------------------------------------------
c The TLNS3D code was developed to solve Reynolds-averaged Navier-Stokes
c Equations to simulate turbulent, viscous flows over three-dimensional
c configurations. A general multiblock grid approach is used to model
c complex configurations.  A multi-stage Runge-Kutta pseudo-time stepping
c scheme is coupled with residual smoothing and multigrid acceleration
c techniques to form an efficient algorithm for solving transonic viscous
c flows over aerodynamic configurations of practical interest.
c
c The TLNS3D framework is licensed under the Apache License, Version 2.0
c (the "License"); you may not use this application except in compliance
c with the License. You may obtain a copy of the License at
c http://www.apache.org/licenses/LICENSE-2.0. 

c Unless required by applicable law or agreed to in writing, software
c distributed under the License is distributed on an "AS IS" BASIS,
c WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
c See the License for the specific language governing permissions and
c limitations under the License.
c----------------------------------------------------------------------------------------------
c
      subroutine  setpch2(imn,jmn,kmn,mgrlev,mbloc,ngrid,nbloc,
     .            ibloc,igrid,lswpchb,lswpche,
     .            mxpchs,mpchitm,nswpchb,npchitm,lspchb1,lspchf1,
     .            lspchb2,lspchf2,ipitmb1,ipitmb2,jpitmb1,jpitmb2,
     .            kpitmb1,kpitmb2,frc,nodes                     )
c=======================================================================
c 
c
c     object : to read the patcher information from data files generated
c              by a preprocessor and convert this information into
c              a form compatible with tlns3d-mb data structure
c
c              the global patcher information a is read from ipfil1
c              which identifies all the patched cells 
c
c              The information about the source cell and their
c              contribution to conserved variables on the
c              target patched cells is read from ipfil2
c
c     Note   : Currently the files ipfil1 and ipfil2 are
c              generated by Paul Pao and Hamid's preprocessor
c
c     Initial coding : by v.n.vatsa, nasa langley ( Sept. 1994)
c     Last major revision : by v.n.vatsa (Jan. 1997) for reducing
c              patcher related array sizes for distributed version
c
c
c
c---  control parameters on ipfil2 :
c
c        this file contains detailed information regarding patch/interface
c        b.c's, such as block, face and cell indices of the source cell,
c        as well as the area weighted influence coefficient needed for
c        computing the contribution of the source cell to the target cell.
c        note that a given target cell may have multiple source cells
c        belonging to different blocks/faces
c
c     ngridpp   : no. of mg levels for which patcher info. follows
c     nswpcht   : total no. of surface segments with patched cells 
c                 at current grid level (includes all blocks)
c                (these patches admit existence  of multiple sources)
c     nswpchb   : no. of surface segments with patched cells on
c                 current block (computed using following info.)
c
c----     next 5 items are repeated nswpcht times
c
c      npchitm  : no. of source cells (items) contributing to patched
c                 cells on current surface segment
c                (next 5 items are repeated npchitm times)
c      lspchb1  : target (to or block 1) block  identifier
c                 for the patched surface segment
c      lspchf1  : target (to or block 1, face 1) block-face identifier
c                 for the patched surface segment
c      lspchb2  : source (from or block 2) block identifier
c                 for the patched surface segment
c      lspchf2  : source (from or block 2, face 2) block-face identifier
c                  for the patched surface segment
c
c-----    next 6 items are repeated npchitm times
c    
c      ipitmb1  : i-index of the target (to or block 1) cell for patching
c      jpitmb1  : j-index of the target (to or block 1) cell for patching
c      kpitmb1  : k-index of the target (to or block 1) cell for patching
c
c      ipitmb2  : i-index of the source (from or block 2) cell for patching
c      jpitmb2  : j-index of the source (from or block 2) cell for patching
c      kpitmb2  : k-index of the source (from or block 2) cell for patching
c
c      frc      : fractional area weighted ratio of source cell
c---
c

c
      dimension nswpchb  (mbloc,mgrlev),   npchitm(mxpchs,mgrlev),
     .          lswpchb  (mbloc,mgrlev),   lswpche(mbloc,mgrlev) ,
     .          lspchb1 (mxpchs,mgrlev),   lspchf1(mxpchs,mgrlev),
     .          lspchb2 (mxpchs,mgrlev),   lspchf2(mxpchs,mgrlev),
     .          ipitmb1(1),   ipitmb2(1),
     .          jpitmb1(1),   jpitmb2(1),
     .          kpitmb1(1),   kpitmb2(1),
     .          frc   (1)
c
      dimension nodes(1)
c
      common/files/ iread,iwrit,igrdfil,irstfil,isavfil,ipltfil
     .                   ,imapfil,ipfil1,ipfil2,irhtall,irhtphy
     .                   ,igpfil,iqpfil,idatfil,ipntfil,iavgfil
c
      common/facetr/ ifacetr(6),ipatchg
c
cvn   data ifacetr/3,4,5,6,1,2/
c
c     start setting up source/target info. for patched cells
c
c
c-----   start reading information from file ipfil2
c
c
c--   initialize item (patched cell pieces) number
      litmnum = 0
c
      do 2000 nn=lswpchb(ibloc,igrid)+1,lswpche(ibloc,igrid)
c
c---read header info as dummy info --
      read (ipfil2,*)
      read (ipfil2,*)
      read (ipfil2,*)
      read (ipfil2,*) iblock1,iface1,iblock2,iface2,nitems
c     if (litmnum+nitems.gt.mpchitm) then
c       write (iwrit,'(" litmnum = ",i6," exceeds dimension",
c    .    " of mpchitm = ",i6," in setpch")')
c    .    litmnum+nitems,mpchitm
c       call ERREXIT (nodes) 
c     endif
c     npchitm(nn,igrid)      = nitems
      lspchb1(nn,igrid)      = iblock1
      lspchf1(nn,igrid)      = iface1
      lspchb2(nn,igrid)      = iblock2
      lspchf2(nn,igrid)      = iface2
c
      if(npchitm(nn,igrid).ne.nitems) then
        write (iwrit,'(2x,"npchitm conflicts with nitems "/)')
        write (iwrit,'(2x,"npchitm nitems iblock igrid patch#  "/)')
        write (iwrit,'(2x,5i7)') npchitm(nn,igrid),nitems,iblock1,
     .                          igrid,nn
        write (iwrit,'(2x,"stop in  setpch2 before do 2030 "/)')
c
        call ERREXIT (nodes)
      endif
c
c
      if(npchitm(nn,igrid).le.0) go to 2031
      itembeg     = litmnum + 1
      itemend     = itembeg + npchitm(nn,igrid)-1
      do 2030 item=itembeg,itemend
c
      read (ipfil2,*) idum1,idum2,idum3,idum4,idum5,idum6,dum
c
c
      ipitmb1(item) = idum1
      jpitmb1(item) = idum2
      kpitmb1(item) = idum3
      ipitmb2(item) = idum4
      jpitmb2(item) = idum5
      kpitmb2(item) = idum6
      frc    (item) = dum
c
c     adjust the i,j,k locations of cells to account for the offset
c     due to imn,jmn,kmn in tlns3d-mb
c
      ipitmb1(item) = ipitmb1(item) + imn
      jpitmb1(item) = jpitmb1(item) + jmn
      kpitmb1(item) = kpitmb1(item) + kmn
      ipitmb2(item) = ipitmb2(item) + imn
      jpitmb2(item) = jpitmb2(item) + jmn
      kpitmb2(item) = kpitmb2(item) + kmn
c
 2030 continue
      litmnum = itemend
 2031 continue
      
 2000 continue
c
c
      return
      end
