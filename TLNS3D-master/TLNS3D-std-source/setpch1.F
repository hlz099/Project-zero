c------------------------------------------------------------------------------
c The TLNS3D code was developed to solve Reynolds-averaged Navier-Stokes
c Equations to simulate turbulent, viscous flows over three-dimensional
c configurations. A general multiblock grid approach is used to model
c complex configurations.  A multi-stage Runge-Kutta pseudo-time stepping
c scheme is coupled with residual smoothing and multigrid acceleration
c techniques to form an efficient algorithm for solving transonic viscous
c flows over aerodynamic configurations of practical interest.
c
c The TLNS3D framework is licensed under the Apache License, Version 2.0
c (the "License"); you may not use this application except in compliance
c with the License. You may obtain a copy of the License at
c http://www.apache.org/licenses/LICENSE-2.0. 

c Unless required by applicable law or agreed to in writing, software
c distributed under the License is distributed on an "AS IS" BASIS,
c WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
c See the License for the specific language governing permissions and
c limitations under the License.
c----------------------------------------------------------------------------------------------
c
      subroutine  setpch1(imn,jmn,kmn,mgrlev,mbloc,ngrid,nbloc,
     .            ibloc,igrid,
     .            ntpchcb,npchcbf,ipatchc,jpatchc,kpatchc,nodes)
c=======================================================================
c 
c
c     object : to read the patcher information from data files generated
c              by a preprocessor and convert this information into
c              a form compatible with tlns3d-mb data structure
c
c              the global patcher information a is read from ipfil1
c              which identifies all the patched cells 
c
c              The information about the source cell and their
c              contribution to conserved variables on the
c              target patched cells is read from ipfil2
c
c     Note   : Currently the files ipfil1 and ipfil2 are
c              generated by Paul Pao and Hamid's preprocessor
c
c     initial coding : by v.n.vatsa, nasa langley ( Sept. 1994)
c     last major revision: by v.n.vatsa Jan. 1997, to reduce patcher
c                          related arrays from ipfil1 in distributed version
c
c
c---  control parameters on ipfil1, (global patch controller):
c
c        the information on this file is used for detecting and initializing
c        the conserved variables on the cells affected by patch/interface
c        boundary conditions
c
c     ngridp    : no. of mg levels for which global patcher info. follows
c     ntpchcb   : total no. of patched cells on a block (includes all faces)
c     npchcbf   : total no. of cells with patch/interface b.c. on a block face
c                (6 entries, one for each face, 0 if no patched cells on face)
c
c     ipatchc   
c     jpatchc   : i,j and k idices of cells with patch/interface b.c.
c     kpatchc     on a block/face
c
c                (above triplet is repeated to correspond to npchcbf entries)
c
c---
c

      dimension   ntpchcb(mbloc,mgrlev), npchcbf(6,mbloc,mgrlev),
     .            ipatchc(1), jpatchc(1) , kpatchc(1)
c
      dimension   nodes(1)
c
      common/files/ iread,iwrit,igrdfil,irstfil,isavfil,ipltfil
     .                   ,imapfil,ipfil1,ipfil2,irhtall,irhtphy
     .                   ,igpfil,iqpfil,idatfil,ipntfil,iavgfil
c
      common/facetr/ ifacetr(6),ipatchg
c
cvn   data ifacetr/3,4,5,6,1,2/
c
c
      lpchcb = 1
c
c
c---read header info as dummy info --
      read (ipfil1,*) 
      read (ipfil1,*) 
      read (ipfil1,*) 
      read (ipfil1,*) 
      read (ipfil1,*) 
      read (ipfil1,*) 
c----------------------------------
      read (ipfil1,*) iblock1
c
      if(iblock1.ne.ibloc) then
        write (iwrit,'(2x,"iblock1 conflicts with ibloc "/)')
        write (iwrit,'(2x,"iblock1 ibloc  "/)')
        write (iwrit,'(2x,2i7)') iblock1, ibloc
        write (iwrit,'(2x,"stop in  setpch1 after reading iblock1"/)')
c
        call ERREXIT (nodes)
      endif
c
      read (ipfil1,*) idum1,idum2,idum3,idum4,idum5,idum6,idum7,idum8
     .               ,idum9,idum10,idum11,idum12,idum13,idum14,idum15
     .               ,idum16,idum17,idum18,idum19,idum20,idum21
c
c     ntpchcb(iblock1,igrid)     = idum1
c
      if(ntpchcb(ibloc,igrid).ne.idum1) then
        write (iwrit,'(2x,"ntpchcb conflicts for ibloc "/)')
        write (iwrit,'(2x,"ntpchcb ntpchcbnew ibloc  "/)')
        write (iwrit,'(2x,3i7)') ntpchcb(ibloc,igrid),idum1,ibloc
        write (iwrit,'(2x,"stop in  setpch1 after reading idum21"/)')
c
        call ERREXIT (nodes)
      endif
c
      npchcbf(1,iblock1,igrid)   = idum10
      npchcbf(2,iblock1,igrid)   = idum11
      npchcbf(3,iblock1,igrid)   = idum12
      npchcbf(4,iblock1,igrid)   = idum13
      npchcbf(5,iblock1,igrid)   = idum14
      npchcbf(6,iblock1,igrid)   = idum15
c
      if(ntpchcb(ibloc,igrid).le.0) go to 1701
Cc--------
c     note: the face numbering convention used in this subroutine
c           corresponds to the convention used in the pre-processor
c           used for generating the patcher information
c          ( currently we are using Paul Pao & Hamid's convention)
c           The face numbering convention of TLNS3D-MB is recovered
c           through the face-transformation array "ifacetr", which is
c           supplied on top of this routine via data statement.
c---------
c
c     read addresses of patched cells
c
      do 1600 iface=1,6
      if (npchcbf(iface,iblock1,igrid).gt.0) then
c
        lpchce = lpchcb + npchcbf(iface,iblock1,igrid) - 1
c
        do 1030 nn=lpchcb,lpchce
c
        read (ipfil1,*) ipatchc(nn), jpatchc(nn),
     .                  kpatchc(nn)
c
c       adjust index for imin,jmin or kmin face
c
        go to (1100,1030,1300,1030,1500,1030) iface
c
 1100   jpatchc(nn) = 0
        go to 1030
c
 1300   kpatchc(nn) = 0
        go to 1030
c
 1500   ipatchc(nn) = 0
c
 1030   continue
c
        lpchcb = lpchce + 1
c
      endif
c
c     end loop over faces
 1600 continue
c
c
c     adjust the i,j,k locations of cells to account for the offset
c     due to imn,jmn,kmn in tlns3d-mb
c
      do 1700 nn=1,lpchce
      ipatchc(nn) = ipatchc(nn) + imn
      jpatchc(nn) = jpatchc(nn) + jmn
      kpatchc(nn) = kpatchc(nn) + kmn
 1700 continue
 1701 continue
c
      return
      end
